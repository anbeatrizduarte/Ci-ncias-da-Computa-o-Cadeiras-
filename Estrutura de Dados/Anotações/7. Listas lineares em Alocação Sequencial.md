
#### Sobre

A alocação sequencial é uma forma de implementação de listas lineares onde os elementos são armazenados em posições contíguas da memória. Isso geralmente é feito utilizando arrays (vetores).

Ou seja, todos os elementos ficam lado a lado na memória, como em uma linha de caixas. Você pode ver mais sobre em [[6. Alocação Sequencial]].

##### Representação visual

```makefile
Index:    0     1     2     3     4
         ┌───┬────┬────┬────┬────┐
Element: │10 │ 20 │ 30 │    │    │
         └───┴────┴────┴────┴────┘
Tamanho: 3
```

##### Comparação entre lista linear e lista com alocação sequencial


|             Aspector             | Lista linear (conceito)             | Lista com Alocação Sequencial    |
| :------------------------------: | ----------------------------------- | -------------------------------- |
|          **Abstração**           | Lógica (sequência de dados)         | Implementação concreta com array |
|           **Tamanho**            | Variável (depende da implementação) | Fixo (pré-definido)              |
|      **Acesso por posição**      | Pode ser sequencial ou direto       | Direto (`O(1)`)                  |
| **Inserção/rem. no início/meio** | Possível, mas cara                  | Requer deslocamento (`O(n)`)     |
|      **Inserção no final**       | Simples, se houver espaço           | O(1)                             |
|   **Crescimento da Estrutura**   | Manual (precisa realocar array)     | Difícil (tamanho fixo)           |

___

#### Estrutura Interna da Lista com Alocação Sequencial

As estruturas desse tipo de lista possuem alguns componentes básicos, como:

- **Array de dados:** onde os elementos são armazenados
- **Variável de controle do tamanho:** controla quantos elementos estão sendo usados no array.

Exemplo visual:

```java
int[] elementos = new int[5] // capacidade máxima de 5
int tamanho = 3;

elementos = [10, 20, 30, _, _] // representa espaço livre
```

```pseudocodigo
INICIO
  Declarar array ELEMENTOS[CAPACIDADE]
  Declarar inteiro TAMANHO = 0
FIM
```


---

#### Operações básicas

As listas com alocação sequencial possuem algumas operações básicas, sendo elas:

- Inicializar
- Retornar
- Exibir
- Buscar
- Incluir
- Excluir
- Reinicializar

##### Exemplos práticos

- **Inserção no final**
	Teoria: colocar o novo elemento na próxima posição disponível
	Custo: `O(1)`, se houver espaço

```java
public boolean adiciona(int n) {
	if (tamanho < elementos.length) {
		elementos[tamanho] = valor;
		tamanho++;
		return true;
	}
	return false; // sem espaço
}
```

```
FUNÇÃO adiciona(valor)
  SE TAMANHO < CAPACIDADE ENTÃO
    ELEMENTOS[TAMANHO] ← valor
    TAMANHO ← TAMANHO + 1
    RETORNAR verdadeiro
  SENÃO
    RETORNAR falso
FIM
```


- **Inserção no Início ou Meio**
	Teoria: precisa deslocar os elementos à direita para abrir espaço
	Custo: `O(n)`

```java
public boolean adicionaNaPosicao(int posicao, int valor) {
	if (posicao < 0 || posicao > tamanho || tamanho == elementos.length) return false;
	
	for (int i = tamanho - 1; i >= posicao; i--) {
		elementos[i + 1] = elementos[i]; // desloca para a direita
	}

	elementos[posicao] = valor;
	tamanho++;
	return true;
}
```

```
FUNÇÃO adicionaNaPosicao(posicao, valor)
  SE posicao < 0 OU posicao > TAMANHO OU TAMANHO = CAPACIDADE ENTÃO
    RETORNAR falso
  FIMSE

  PARA i DE TAMANHO - 1 ATÉ posicao PASSO -1 FAÇA
    ELEMENTOS[i + 1] ← ELEMENTOS[i]
  FIMPARA

  ELEMENTOS[posicao] ← valor
  TAMANHO ← TAMANHO + 1
  RETORNAR verdadeiro
FIM
```


- **Remoção**
	Teoria: remover o elemento e deslocar os posteriores para a esquerda
	Custo: `O(n)`

```java
public boolean remove(int posicao) {
	if (posicao < 0 || posicao >= tamanho) return false;
	
	for (int i = posicao; i < tamanho - 1; i++) {
		elementos[i] = elementos[i + 1]; // desloca para a esquerda
	}
	
	tamanho--;
	return true;
}
```

```
FUNÇÃO remove(posicao)
  SE posicao < 0 OU posicao ≥ TAMANHO ENTÃO
    RETORNAR falso
  FIMSE

  PARA i DE posicao ATÉ TAMANHO - 2 FAÇA
    ELEMENTOS[i] ← ELEMENTOS[i + 1]
  FIMPARA

  TAMANHO ← TAMANHO - 1
  RETORNAR verdadeiro
FIM
```


- **Acesso direto**
	Teoria: com o índice, acessa diretamente a posição
	Custo: `O(1)`

```java
public int get(int posicao) {
	if (posicao < 0 || posicao >= tamanho) throw new IndexOutOfBoundsException();
	return elementos[posicao];
}
```

```
FUNÇÃO get(posicao)
  SE posicao < 0 OU posicao ≥ TAMANHO ENTÃO
    LANÇAR ERRO "Índice inválido"
  FIMSE

  RETORNAR ELEMENTOS[posicao]
FIM
```

Para contornar o tamanho fixo, o Java (e outras linguagens) utilizam a realocação dinâmica, que consistem em:

1. Criar um array maior (ex.: o dobro do tamanho atual)
2. Copia todos os dados antigos
3. Substitui o array antigo pelo novo

